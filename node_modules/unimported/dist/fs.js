"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.resolveFilesSync = exports.list = exports.writeJson = exports.readJson = exports.writeText = exports.readText = exports.deleteFile = exports.exists = void 0;
const fs_1 = __importDefault(require("fs"));
const path_1 = require("path");
const glob_1 = __importDefault(require("glob"));
const util_1 = __importDefault(require("util"));
const json5_1 = __importDefault(require("json5"));
const resolve_1 = __importDefault(require("resolve"));
const globAsync = util_1.default.promisify(glob_1.default);
const readFileAsync = util_1.default.promisify(fs_1.default.readFile);
const writeFileAsync = util_1.default.promisify(fs_1.default.writeFile);
const existsAsync = util_1.default.promisify(fs_1.default.exists);
function exists(path, cwd = '') {
    return __awaiter(this, void 0, void 0, function* () {
        return yield existsAsync((0, path_1.join)(cwd, path));
    });
}
exports.exists = exists;
function deleteFile(path, cwd = '') {
    return __awaiter(this, void 0, void 0, function* () {
        return util_1.default.promisify(fs_1.default.rm)((0, path_1.join)(cwd, path));
    });
}
exports.deleteFile = deleteFile;
function readText(path, cwd = '') {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            return yield readFileAsync((0, path_1.join)(cwd, path), { encoding: 'utf8' });
        }
        catch (e) {
            return '';
        }
    });
}
exports.readText = readText;
function writeText(path, data, cwd = '') {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            return yield writeFileAsync((0, path_1.join)(cwd, path), data, { encoding: 'utf8' });
        }
        catch (e) {
            return;
        }
    });
}
exports.writeText = writeText;
function readJson(path, cwd = '.') {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            const text = yield readText(path, cwd);
            return text ? json5_1.default.parse(text) : undefined;
        }
        catch (e) {
            console.error('\nfile does not contain valid json:', path, 'error: ', e);
            return undefined;
        }
    });
}
exports.readJson = readJson;
function writeJson(path, data, cwd = '.') {
    return __awaiter(this, void 0, void 0, function* () {
        const text = JSON.stringify(data, null, '  ');
        return yield writeText(path, text, cwd);
    });
}
exports.writeJson = writeJson;
function list(pattern, cwd, options = {}) {
    return __awaiter(this, void 0, void 0, function* () {
        const { extensions } = options, globOptions = __rest(options, ["extensions"]);
        // transform:
        // - ['.js', '.tsx'] to **/*.{js,tsx}
        // -['.js'] to **/*.js
        const normalizedExtensions = extensions === null || extensions === void 0 ? void 0 : extensions.map((x) => x.replace(/^\./, ''));
        const wrappedExtensions = (extensions === null || extensions === void 0 ? void 0 : extensions.length) === 1
            ? normalizedExtensions
            : `{${normalizedExtensions}}`;
        const fullPattern = Array.isArray(extensions)
            ? `${pattern}.${wrappedExtensions}`
            : pattern;
        return yield globAsync(fullPattern, Object.assign({ cwd, realpath: true }, globOptions));
    });
}
exports.list = list;
function resolveFilesSync(options, extensions) {
    const basedir = process.cwd();
    return options
        .map((file) => {
        try {
            if (!file) {
                return;
            }
            file = file.startsWith('./') ? file : `./${file}`;
            return (file &&
                resolve_1.default
                    .sync(file, {
                    basedir,
                    extensions,
                })
                    .replace(/\\/g, '/'));
        }
        catch (_a) { }
    })
        .map((file) => file && (0, path_1.relative)(basedir, file));
}
exports.resolveFilesSync = resolveFilesSync;
